# MChat 技术设计方案

> 依据《产品需求方案（PRD）v1.2》编制的详细技术设计，用于指导服务端、客户端与 Broker 的实现与部署。

**文档版本**：1.1  
**对应 PRD 版本**：1.2

---

## 一、系统架构

### 1.1 总体架构

```
                    ┌─────────────────────────────────────────────────────────┐
                    │                    MQTT Broker 集群                       │
                    │  (EMQX / AWS IoT Core，共享订阅、ACL、持久会话)             │
                    └─────────────────────────────────────────────────────────┘
                         ▲           ▲           ▲           ▲
        发布/订阅         │           │           │           │
    ┌────────────────────┼───────────┼───────────┼───────────┼────────────────────┐
    │                    │           │           │           │                    │
    │  客户端 A          │  客户端 B │  服务端   │  客户端 C │  AI Agent 客户端   │
    │  (client_id_a)     │           │ (gateway) │           │  (client_id_agent)  │
    │  employee_id=u1    │  u2       │           │  u3       │  employee_id=ai_1   │
    └────────────────────┴───────────┴───────────┴───────────┴────────────────────┘
                                    │
                                    ▼
                    ┌─────────────────────────────────────────────────────────┐
                    │                    业务服务层（可选拆分）                  │
                    │  员工/组织/权限 | 群组 | 消息中继（仅实时） | Agent 路由   │
                    └─────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ▼               ▼
              ┌──────────┐   ┌──────────┐
              │ 关系库   │   │ 对象存储  │
              │ 组织/群组│   │ 大文件   │
              │ 会话映射 │   └──────────┘
              └──────────┘
```

- **Broker**：仅做 MQTT 消息路由与会话管理，不解析业务 payload。支持 TLS、ACL、共享订阅、持久会话（Clean Session=0）。
- **服务端**：以 MQTT 客户端身份连接 Broker，订阅请求主题、处理业务、写库、发布响应与投递消息。可单进程内聚或拆分为「网关 + 业务微服务」，内部通过内存/消息队列传递。
- **客户端**：以 MQTT 客户端身份连接 Broker，发布请求、订阅响应与收件箱/群/状态等主题。

### 1.2 技术选型

| 角色 | 技术栈 | 说明 |
|------|--------|------|
| **服务端** | Node.js + TypeScript | MQTT 网关、业务 Handler、ACL/鉴权、消息中继、Agent 路由等；与 Broker、关系库、对象存储对接。 |
| **客户端 SDK** | TypeScript、Python | 面向业务集成方：封装连接、订阅、请求-响应关联、重试等；TS 与 Python 双语言，便于 Web/Node 与 Python 生态接入。 |
| **管理端** | React + MQTT | Admin Web 管理系统：通过 MQTT 请求-响应（与普通客户端相同，使用管理员身份）完成员工/部门/群组、Agent 配置、审计等；React 前端 + MQTT 直连 Broker，无需单独 HTTP 管理 API。 |

- **统一协议**：服务端、SDK、Admin 均基于 MQTT 与同一套 Topic/Payload 约定（见 PRD 与《消息交互接口与示例》），仅权限与使用场景不同。

### 1.3 服务端订阅与水平扩展

- 服务端**必须**订阅客户端请求主题，才能接收所有请求。主题通配符：**`mchat/msg/req/+/+`**（第一层为 client_id，第二层为 seq_id）。
- **高并发**：使用 Broker 的**共享订阅**，将请求分摊到多个服务实例，避免重复消费。例如 EMQX：`$share/gateway/mchat/msg/req/+/+`，同一 group 内仅一个实例收到每条消息。
- 单实例内：从 topic 解析出 `client_id`、`seq_id`，从 payload 解析 `action`，路由到对应 handler；处理完成后向 **同一 Broker** 发布响应到 `mchat/msg/resp/{client_id}/{seq_id}`。

### 1.4 部署拓扑建议

| 组件       | 部署方式 |
|------------|----------|
| MQTT Broker | 集群部署（如 EMQX 3 节点以上），支持持久会话与持久化；ACL 由服务端通过 Broker HTTP API 动态写入。 |
| 服务端     | Node.js + TypeScript，无状态多实例，前接负载均衡（或仅多实例连同一 Broker，依赖共享订阅）；连接同一关系库、对象存储；**不连接消息库**（系统不存储消息历史）；**暂不使用缓存**（如 Redis），会话映射与限流等从关系库或进程内存获取。 |
| 管理端     | React 单页应用，静态资源托管（CDN 或与网关同域）；浏览器通过 MQTT over WSS 直连 Broker，使用管理员账号 client_id，与 SDK 共用同一套 Topic/Payload 接口。 |
| 关系库     | 主从或集群，存组织、员工、群组、权限、会话映射（client_id↔employee_id）、审计日志。 |
| 对象存储   | S3 兼容对象存储，存大文件；临时 URL 由服务端通过 MQTT 请求-响应（如 file.upload_url）下发。可实现为 AWS S3、阿里云 OSS、MinIO 等。 |

---

## 二、数据模型与存储

### 2.1 核心实体

#### 2.1.1 员工（employee）

| 字段 | 类型 | 说明 |
|------|------|------|
| employee_id | string, PK | 全局唯一，人类与 AI Agent 共用 |
| name | string | 显示名 |
| department_id | string, FK | 所属部门 |
| manager_id | string, FK | 汇报上级 employee_id |
| is_ai_agent | boolean | 是否 AI Agent |
| agent_profile | json | 仅 is_ai_agent=true 时：model_type, capabilities[], trigger_keywords[], webhook_endpoint, response_timeout, auto_join_groups[] 等 |
| skills_badge | string[] | 技能标签，如 ["⚡实时响应"] |
| status | enum | 可选：active / disabled |
| created_at, updated_at | timestamp | |

- **人类员工**：agent_profile 为空；**AI Agent**：必填 webhook_endpoint、capabilities、response_timeout 等（见 PRD 2.3.1）。

#### 2.1.2 部门（department）

| 字段 | 类型 | 说明 |
|------|------|------|
| department_id | string, PK | |
| name | string | |
| parent_id | string, FK | 上级部门，根为 null |
| sort_order | int | 同级排序 |
| created_at, updated_at | timestamp | |

#### 2.1.3 群组（group）

| 字段 | 类型 | 说明 |
|------|------|------|
| group_id | string, PK | |
| name | string | |
| creator_employee_id | string, FK | |
| description, avatar | string | 可选 |
| created_at, updated_at | timestamp | |

#### 2.1.4 群成员（group_member）

| 字段 | 类型 | 说明 |
|------|------|------|
| group_id | string, PK | |
| employee_id | string, PK | |
| role | enum | 如 owner / admin / member |
| joined_at | timestamp | |

#### 2.1.5 连接会话（client_session，client_id ↔ employee_id）

| 字段 | 类型 | 说明 |
|------|------|------|
| client_id | string, PK | MQTT ClientId 或服务端下发的连接级 ID |
| employee_id | string, FK | 当前登录员工 |
| device_info | string | 可选，设备/端标识 |
| connected_at | timestamp | |
| expires_at | timestamp | 可选，会话过期 |

- 用于鉴权：从 topic 取出 client_id，查表得 employee_id，再做权限校验。多端即同一 employee_id 多条 client_session。

#### 2.1.6 消息（不在服务端落库）

**系统不存储消息历史**，无 message 表。发消息时服务端仅做实时中继：

- **生成并返回**：msg_id（全局唯一）、sent_at（ISO8601），在响应 payload 中返回给发送方。
- **投递**：将 payload（msg_id, type, from_employee_id, to_employee_id 或 group_id, content, sent_at, quote_msg_id 等）发布到 `mchat/inbox/{employee_id}` 或 `mchat/group/{group_id}`，**不写入任何数据库**。
- **历史与离线**：由**客户端自行存储**。客户端收到收件箱/群主题的消息后，在本地落库或文件存储，并自行实现历史列表、分页与多端同步（若需）。

### 2.2 存储选型与职责

| 存储 | 用途 |
|------|------|
| 关系型 DB（如 PostgreSQL/MySQL） | 员工、部门、群组、群成员、权限、client_session、审计日志表；**不存消息内容**。在线状态、client_id→employee_id 映射、群成员列表、限流计数等均从关系库或服务进程内存获取，**暂不使用独立缓存（如 Redis）**。 |
| 对象存储   | 图片/文件；服务端生成临时 URL 经 MQTT 返回 |

### 2.3 消息 content 格式（投递 payload）

与 PRD 2.7.3 一致：投递时 `content` 为 string（纯文本）或 object。object 时：

- `type`: "text" | "image" | "file"
- `body`: 对应结构，如 text 为 `{"text":"..."}`，image 为 `{"url":"...","width", "height"}`，file 为 `{"url":"...","name","size"}`

---

## 三、服务端设计

### 3.1 MQTT 网关层

- **连接**：服务端使用固定 ClientId（如 `mchat_gateway_1`）或带实例 ID 的 ClientId 连接 Broker，订阅 **`$share/gateway/mchat/msg/req/+/+`**（或非共享的 `mchat/msg/req/+/+`）。
- **收包**：收到消息后解析 topic 得 `client_id`、`seq_id`，解析 payload 得 `action`、其余字段。
- **鉴权**：用 client_id 查 client_session 得 employee_id；若无则返回 401；若有，根据 action 做权限校验（如建群需管理员、发群消息需在群内）。
- **路由**：按 action 分发到对应 Handler（见下表），Handler 内可访问 DB、调用 Agent Webhook 等（暂不使用外部缓存）。
- **响应**：Handler 返回 (code, message, data)；网关统一发布到 `mchat/msg/resp/{client_id}/{seq_id}`，QoS=1 或 2。

### 3.2 Action 与 Handler 映射

| action | 说明 | 主要逻辑 |
|--------|------|----------|
| auth.bind | 会话绑定（可选） | 从 payload 或凭证解析 employee_id，写 client_session，可选写 Broker ACL |
| auth.challenge | 敏感操作二次验证 | 生成一次性 token 写入关系库（短 TTL 表）或进程内存，响应返回 challenge_id；后续敏感 action 携带 challenge_id+token 校验后执行 |
| group.create | 创建群组 | 校验管理员/权限 → 写 group、group_member → 通知成员 inbox |
| group.dismiss | 解散群组 | 校验创建者/管理员 → 软删或删 group、成员 → 通知 |
| group.member_add / group.member_remove | 增删成员 | 校验权限 → 改 group_member → 通知相关 inbox |
| employee.create / employee.update | 员工创建/更新 | 校验管理员 → 写/改 employee 表 → **employee.create 成功时在 data 中返回 mqtt_connection**（broker_host, broker_port, use_tls, client_id_scheme 或 mqtt_username/mqtt_password/token），供该员工客户端连接 Broker；可选 profile 推送 |
| org.tree | 组织树 | 查 department + employee，组装树与列表返回 |
| config.storage | 获取对象存储读写配置 | 校验当前员工身份 → 生成临时凭证或预签名策略（如 STS 或预签名 URL 前缀），返回 endpoint、bucket、region、credentials 或 url_prefix、expires_at；**客户端据此直接上传/下载文件**，无需经服务端中转 |
| msg.send_private | 发单聊 | 校验 to_employee_id 合法 → 生成 msg_id、sent_at，**不落库** → 发布到 mchat/inbox/{to_employee_id}，响应返回 msg_id、sent_at |
| msg.send_group | 发群聊 | 校验发件人在群内 → 生成 msg_id、sent_at，**不落库** → 发布到 mchat/group/{group_id}，响应返回 msg_id、sent_at |
| msg.read_ack | 已读回执 | 校验 reader 为当前员工 → 落库或仅转发，可选推送已读状态 |
| agent.capability_list | Agent 能力列表 | 查 is_ai_agent=true 的 employee + agent_profile，按 skill 过滤后返回 |
| file.upload_url / file.download_url | 大文件单次临时 URL（可选） | 校验身份 → 调对象存储（S3 兼容 API）生成单次临时 URL → 返回 data 中的 url、expires_at 等；与 config.storage 可并存（配置用于客户端直连，本 action 用于按次链接） |

- **错误码**：按 PRD 2.7.1，0 成功，4xx 业务错误，5xx 服务端错误（含 504 超时）。Handler 内异常统一映射为 500，Agent 超时映射为 504。

### 3.3 消息中继（仅实时，不落库）

- **单聊**：msg.send_private 生成 msg_id、sent_at 后，立即向 `mchat/inbox/{to_employee_id}` 发布 payload（msg_id, type, from_employee_id, content, sent_at 等），响应返回 msg_id、sent_at。**不写入数据库**。
- **群聊**：msg.send_group 生成 msg_id、sent_at 后，向 `mchat/group/{group_id}` 发布，所有订阅该主题的成员会收到。**不写入数据库**。
- **离线与历史**：服务端不存储、不补推。离线期间的消息是否可达取决于 Broker 持久会话与保留策略；历史由**客户端**将收到的消息本地存储后自行展示。

### 3.4 AI Agent 路由与调用

- **触发**：在 msg.send_private 或 msg.send_group 处理中，若检测到 content 含 @某 Agent 或 trigger_keywords，则解析目标 employee_id（is_ai_agent=true）。
- **调用**：服务端向该 Agent 的 webhook_endpoint 发起 HTTP POST，payload 含：消息内容、发送者 employee_id、conversation_type（private/group）、group_id；**会话上下文**：若客户端在请求中携带了 `context_messages`（近期消息数组），则一并传给 Agent，否则不传历史（服务端无存储）。
- **响应**：Agent 返回的回复内容，由服务端生成 msg_id、sent_at，**不落库**，直接投递到原会话（inbox 或 group）。若超时，返回 504 给发送方，并可选向原会话投递一条「Agent 暂时无响应，可转人工」的系统消息。
- **限流与安全**：按 employee_id（Agent）做 QPS 限流；对 Agent 返回内容做敏感词过滤后再投递。

### 3.5 审计与限流

- **审计**：对 group.*、employee.*、敏感 action 等，在 Handler 内写审计表（operator_employee_id、action、params、result_code、ts）。
- **限流**：按 client_id 或 employee_id 做令牌桶/滑动窗口，超限返回 429。

---

## 四、客户端设计

### 4.1 连接与身份

- **MQTT 连接信息来源**：**员工注册成功**（如管理员调用 employee.create 或系统完成注册）后，响应 `data` 中的 **mqtt_connection** 即该员工的 MQTT 连接信息（broker_host、broker_port、use_tls、client_id_scheme 或 mqtt_username/mqtt_password/token），客户端据此连接 Broker 并完成登录。
- **client_id**：按 mqtt_connection 中的 client_id_scheme 生成，或格式为 `{employee_id}_{device_id}_{uuid}`；保证同一连接唯一。
- **连接参数**：使用 mqtt_connection 中的 broker_host、broker_port、use_tls 及凭证；Clean Session=0 以利用持久会话与 LWT。
- **可选 auth.bind**：连接成功后发一条 `mchat/msg/req/{client_id}/{seq_id}`，action= auth.bind，payload 含 employee_id（或由服务端从凭证解析），以便服务端写 client_session 并更新 ACL。
- **对象存储配置**：连接 MQTT 后，通过请求 `action: "config.storage"` 获取对象存储读写配置（endpoint、bucket、临时凭证或 URL 策略、expires_at），客户端据此**直接**读取或上传文件。

### 4.2 订阅列表

- **必须**：`mchat/msg/resp/{client_id}/+`（收响应）。
- **按身份**：`mchat/inbox/{employee_id}`（收件箱）。
- **按群**：对用户已加入的每个群订阅 `mchat/group/{group_id}`（列表可从 org.tree 或本地缓存获取，加入新群时新增订阅）。
- **可选**：`mchat/status/+` 或关心的 `mchat/status/{employee_id}`；`mchat/profile/{employee_id}`；`mchat/system/notify`。

### 4.3 发布行为

- **请求**：所有操作请求发布到 `mchat/msg/req/{client_id}/{seq_id}`，payload 含 action 及业务参数（seq_id 以 topic 为准，payload 中不必重复）。seq_id 由客户端生成（UUID 或雪花 ID），保证未完成请求内唯一。
- **状态**：连接成功后发布到 `mchat/status/{employee_id}` payload `{status:"online", updated_at: ISO8601}`，retain=true；LWT 设为同主题 payload `{status:"offline", updated_at:...}`，Broker 在断线时自动发布。

### 4.4 响应关联与重试

- 客户端维护 in-flight 映射：seq_id → { resolve, reject, timeout }。收到 `mchat/msg/resp/{client_id}/{seq_id}` 时从 **topic 取 seq_id** 找到对应 Promise 并 resolve(payload 的 code, message, data)。
- **超时**：建议请求发出后 30s（或按 action 配置）未收到响应则 timeout，根据 PRD 对幂等 action 可重试，非幂等由 UI 提示。
- **重连**：断线重连后重新订阅上述主题；**无服务端历史拉取**，历史从客户端本地存储加载；重连后仅能收到订阅后的新消息。

---

## 五、Broker 与 ACL

### 5.1 Broker 能力要求

- 支持 MQTT 3.1.1 或 5.0、TLS、持久会话、LWT、retain。
- 支持**通配符订阅**（+、#）及**共享订阅**（如 EMQX `$share/group/topic`）。
- 支持**动态 ACL**（通过 HTTP API 或插件，在连接或 auth.bind 后为 client_id 写入允许发布/订阅的主题列表）。

### 5.2 ACL 规则原则（由服务端写入）

- **客户端（client_id = C, 对应 employee_id = E）**：  
  - 允许发布：`mchat/msg/req/C/+`、`mchat/status/E`、可选 `mchat/msg/read_ack`（若采用直接发布方式）。  
  - 允许订阅：`mchat/msg/resp/C/+`、`mchat/inbox/E`、`mchat/profile/E`、`mchat/system/notify`，以及该员工已加入的 `mchat/group/{group_id}`（列表由服务端在加群/退群时更新）。
- **服务端**：允许订阅 `mchat/msg/req/+/+` 或 `$share/gateway/mchat/msg/req/+/+`；允许向任意 `mchat/msg/resp/{client_id}/{seq_id}`、`mchat/inbox/{employee_id}`、`mchat/group/{group_id}`、`mchat/profile/{employee_id}`、`mchat/status/{employee_id}`、`mchat/system/notify` 发布。

### 5.3 认证

- 连接时：Broker 校验用户名/密码或证书；若使用「用户名=employee_id@tenant、密码=token」形式，Broker 仅做连接认证，服务端在 auth.bind 或首次请求时建立 client_id→employee_id 映射。
- 或：Broker 不校验业务，仅做 TLS + ClientId 白名单；业务鉴权完全由服务端根据 client_id 查 client_session 完成。

---

## 六、安全与合规

### 6.1 传输与存储

- **传输**：全链路 TLS 1.3；Broker、服务端、客户端均使用证书或强密码。
- **存储**：**消息内容不落库**；仅业务元数据与审计日志落库。敏感字段可按需加密存储。PRD 约定当前不做 E2EE，由服务端/平台保护传输与元数据。

### 6.2 敏感操作二次验证

- 定义敏感 action 列表（如 employee 删除、权限变更、群解散）。  
- 流程：客户端先发 `auth.challenge`，服务端生成一次性 token 写入关系库（短期 TTL 表）或进程内存，响应返回 challenge_id；客户端再发实际 action 时 payload 带 challenge_id + token，服务端校验通过后执行并失效 token。

### 6.3 审计日志

- 记录：operator_employee_id、client_id、action、请求摘要（不含敏感内容）、code、ts。  
- 保留期：≥180 天（可配置），支持导出与合规查询。

---

## 七、关键流程说明

### 7.1 创建群聊（端到端）

1. 管理员客户端生成 seq_id，发布到 `mchat/msg/req/{client_id}/{seq_id}`，action= group.create，name、member_ids、opts。
2. 服务端网关收包 → 鉴权（client_id→employee_id，校验管理员）→ GroupHandler：写 group、group_member → 发布响应到 `mchat/msg/resp/{client_id}/{seq_id}`，code=0，data 含 group_id。
3. 服务端向每个 member 的 `mchat/inbox/{employee_id}` 发布系统通知（type=system，action=group_created，group_id、name、inviter_id），或同时更新该成员 ACL 允许订阅 `mchat/group/{group_id}`。

### 7.2 发送单聊消息

1. 客户端发布 msg.send_private（to_employee_id、content）→ 服务端鉴权、生成 msg_id 与 sent_at、**不落库**、发布到 `mchat/inbox/{to_employee_id}`，响应返回 msg_id、sent_at。
2. 接收方客户端从 `mchat/inbox/{employee_id}` 收到 payload 后，**由客户端自行落库并展示历史**；服务端不提供历史拉取接口。

### 7.3 AI Agent 消息处理

1. 用户发单聊或群聊，content 含 @ai_sales_001 或「查订单」。  
2. 服务端在 msg.send_private/msg.send_group 逻辑中识别到触发 Agent，解析出 ai_sales_001，查 employee 得 webhook_endpoint、response_timeout。  
3. 服务端 POST webhook，body 含 from_employee_id、content、history[]、conversation_type 等；等待最多 response_timeout 秒。  
4. Agent 返回回复文本/结构化内容；服务端生成 msg_id、sent_at，**不落库**，发布到原会话（inbox 或 group）。  
5. 若超时：响应发送方 504；可选向会话投递一条系统提示「Agent 暂时无响应」。

### 7.4 员工注册与 MQTT / 对象存储配置

1. **注册**：管理员通过 MQTT 请求 `employee.create` 创建员工；服务端写 employee 表，并生成该员工的 MQTT 凭证（或复用统一 Broker 的凭证规则）。
2. **响应**：成功时 `data` 含 `employee_id`、`name`、`created_at` 及 **mqtt_connection**：`broker_host`、`broker_port`、`use_tls`、`client_id_scheme` 或 `mqtt_username`/`mqtt_password`（或 token）。该信息交付给员工（或管理员转交），供其客户端使用。
3. **客户端登录**：员工客户端使用 mqtt_connection 连接 Broker，完成 MQTT 登录与 auth.bind（可选）。
4. **对象存储配置**：客户端连接 MQTT 后，发送 `action: "config.storage"`；服务端校验身份，生成临时凭证或预签名策略，返回 endpoint、bucket、region、credentials 或 url_prefix、expires_at。客户端据此配置 S3 兼容 SDK 或直接发起上传/下载，**直接读写对象存储**，无需经服务端中转文件内容。

---

## 八、可观测性

### 8.1 日志

- **网关**：每条请求打 log（client_id、seq_id、action、latency_ms、code）；不打印完整 payload 以免泄露内容。  
- **业务**：关键写操作（建群、加人、消息投递）打 info；异常打 error 并带 trace_id/msg_id。

### 8.2 指标

- 请求 QPS、按 action 分布、时延 P95/P99、错误码分布（4xx/5xx）。  
- 消息投递：inbox/group 发布条数。  
- Agent：调用次数、超时次数、限流次数。

### 8.3 链路追踪

- 请求维度：client_id + seq_id 作为 correlation_id，从网关到 Handler 到 MQTT 发布，统一传递。  
- 消息维度：msg_id 在投递日志中传递，便于排查单条消息轨迹。

---

## 九、与 PRD 的对应关系

| PRD 章节 | 本方案对应 |
|----------|------------|
| 1.4 系统组成 | 一、系统架构 |
| 2.2 主题体系、身份模型、服务端订阅 | 一、1.2–1.3；五、ACL |
| 2.3 AI Agent | 三、3.4；七、7.3 |
| 2.7 接口设计 | 三、3.2 Action 与 Handler；二、数据模型；四、客户端订阅与发布 |
| 三、非功能需求 | 六、安全；八、可观测性；一、部署 |
| 四、技术约束 | 二、存储选型；五、Broker 能力 |

---

## 十、版本与变更

- **1.0**：初版，覆盖架构、数据模型、服务端/客户端/Broker、安全、关键流程、可观测性，与 PRD v1.1 对齐。  
- **1.1**：与 PRD v1.2 对齐。**不使用时序库**；**系统不存储消息历史**，消息仅实时中继、不落库；移除 message 表、msg.history_private/msg.history_group；历史与离线由客户端自行实现；AI Agent 上下文中的历史改为由客户端可选携带（如 context_messages）。  
- 后续可根据实现反馈与 PRD 变更，在本文档中增补「实现说明」或修订数据表结构、Topic 约定等。
